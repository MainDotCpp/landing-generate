window.addEventListener('load', () => { window.location.host.match(/sb-preview.+squadbeyond.com/) || (document.oncopy = function () { return !1 }, document.addEventListener('contextmenu', (t) => { t.preventDefault() }), document.addEventListener('dragstart', (t) => { t.preventDefault() })) }), window.addEventListener('load', () => {
  const t = document.body.querySelectorAll('.sb-bg-gum-marker'); const e = Array.prototype.slice.call(t, 0); if (e.length === 0)
    return; const n = window.innerHeight || document.body.clientHeight; window.addEventListener('scroll', (t) => { const o = window.pageYOffset !== undefined ? window.pageYOffset : document.documentElement.scrollTop; e.forEach((t) => { const e = t.offsetTop - n + 50; o > e && (t.classList.add('animated', 'sb-bg-gum-marker-animated'), t.classList.remove('sb-bg-gum-marker')) }) }, !1)
}), window.addEventListener('load', () => {
  function t() {} let e; t.prototype = { assign() {
    const t = document.querySelector('.js-m-id'); if (t === null)
      return; if (t.dataset.value != '4')
      return; const e = document.querySelectorAll('a'); const n = Array.prototype.slice.call(e, 0); n.forEach((t) => { const e = new URI(t.getAttribute('href')); if (e.query(!0).sb_tracking === 'true') { let e = t.getAttribute('onclick'); e === null && (e = ''), e += ';this.href=GunosyTransit.link(this.href);', t.setAttribute('onclick', e) } })
  } }, (new t()).assign()
}), window.addEventListener('message', () => { function t() {} let e; t.prototype = { assign() { const t = document.querySelectorAll('.sb-form-iframe'); t.length !== 0 && Array.from(t).forEach((t, e) => { const n = document.querySelector('.js-v-id'); const o = document.querySelector('.js-a-id'); const i = document.querySelector('.js-ab-id'); const r = document.querySelector('.js-f-id'); const s = t.contentWindow.postMessage ? t : undefined; void 0 !== s && document.body.scrollHeight && s.contentWindow.postMessage({ sb_tu_id: n.dataset.value, article_uid: o.dataset.value, ab_test_uid: i.dataset.value, folder_uid: r.dataset.value, posted_beyond: !0 }, '*') }) } }, (new t()).assign() }), window.addEventListener('message', (t) => {
  function e() {} let n; e.prototype = { assign(t) {
    if (!t.data.posted_beyond)
      return; const e = document.querySelectorAll(`[data-sb-form-uid="${t.data.uid}"]`); Array.from(e).forEach((e, n) => { const o = t.data.height; const i = t.data.width; const r = e.querySelector('iframe'); r.style.height = o, r.style.width = i, r.style.margin = '0 auto' })
  } }, (new e()).assign(t)
}), window.addEventListener('DOMContentLoaded', () => { const t = document.querySelectorAll('.sb-form-iframe'); Array.from(t).forEach((t, e) => { const n = new URI(t.src); const o = document.querySelector('.js-folder-form-host'); t.src = `${n.protocol()}://${o.dataset.value}${n.path()}` }) }),
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */
(function () {
  'use strict'; function t(t) { this.time = t.time, this.target = t.target, this.rootBounds = t.rootBounds, this.boundingClientRect = t.boundingClientRect, this.intersectionRect = t.intersectionRect || a(), this.isIntersecting = !!t.intersectionRect; const e = this.boundingClientRect; const n = e.width * e.height; const o = this.intersectionRect; const i = o.width * o.height; this.intersectionRatio = n ? Number((i / n).toFixed(4)) : this.isIntersecting ? 1 : 0 } function e(t, e) {
    const n = e || {}; if (typeof t != 'function')
      throw new Error('callback must be a function'); if (n.root && n.root.nodeType != 1)
      throw new Error('root must be an Element'); this._checkForIntersections = o(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(n.rootMargin), this.thresholds = this._initThresholds(n.threshold), this.root = n.root || null, this.rootMargin = this._rootMarginValues.map((t) => { return t.value + t.unit }).join(' ')
  } function n() { return window.performance && performance.now && performance.now() } function o(t, e) { let n = null; return function () { n || (n = setTimeout(() => { t(), n = null }, e)) } } function i(t, e, n, o) { typeof t.addEventListener == 'function' ? t.addEventListener(e, n, o || !1) : typeof t.attachEvent == 'function' && t.attachEvent(`on${e}`, n) } function r(t, e, n, o) { typeof t.removeEventListener == 'function' ? t.removeEventListener(e, n, o || !1) : typeof t.detatchEvent == 'function' && t.detatchEvent(`on${e}`, n) } function s(t, e) { const n = Math.max(t.top, e.top); const o = Math.min(t.bottom, e.bottom); const i = Math.max(t.left, e.left); const r = Math.min(t.right, e.right); const s = r - i; const c = o - n; return s >= 0 && c >= 0 && { top: n, bottom: o, left: i, right: r, width: s, height: c } } function c(t) {
    let e; try { e = t.getBoundingClientRect() }
    catch (n) {} return e ? (e.width && e.height || (e = { top: e.top, right: e.right, bottom: e.bottom, left: e.left, width: e.right - e.left, height: e.bottom - e.top }), e) : a()
  } function a() { return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 } } function u(t, e) {
    for (let n = e; n;) {
      if (n == t)
        return !0; n = l(n)
    } return !1
  } function l(t) { const e = t.parentNode; return e && e.nodeType == 11 && e.host ? e.host : e && e.assignedSlot ? e.assignedSlot.parentNode : e } if (typeof window == 'object') {
    if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {
      'isIntersecting' in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', { get() { return this.intersectionRatio > 0 } })
    }
    else {
      const d = window.document; const f = []; e.prototype.THROTTLE_TIMEOUT = 100, e.prototype.POLL_INTERVAL = null, e.prototype.USE_MUTATION_OBSERVER = !0, e.prototype.observe = function (t) {
        let e; if (!this._observationTargets.some((e) => { return e.element == t })) {
          if (!t || t.nodeType != 1)
            throw new Error('target must be an Element'); this._registerInstance(), this._observationTargets.push({ element: t, entry: null }), this._monitorIntersections(), this._checkForIntersections()
        }
      }, e.prototype.unobserve = function (t) { this._observationTargets = this._observationTargets.filter((e) => { return e.element != t }), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance()) }, e.prototype.disconnect = function () { this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance() }, e.prototype.takeRecords = function () { const t = this._queuedEntries.slice(); return this._queuedEntries = [], t }, e.prototype._initThresholds = function (t) {
        let e = t || [0]; return Array.isArray(e) || (e = [e]), e.sort().filter((t, e, n) => {
          if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1)
            throw new Error('threshold must be a number between 0 and 1 inclusively'); return t !== n[e - 1]
        })
      }, e.prototype._parseRootMargin = function (t) {
        let e; const n = (t || '0px').split(/\s+/).map((t) => {
          const e = /^(-?(?:\d+(?:\.\d+)?|\.\d+))(px|%)$/.exec(t); if (!e)
            throw new Error('rootMargin must be specified in pixels or percent'); return { value: Number.parseFloat(e[1]), unit: e[2] }
        }); return n[1] = n[1] || n[0], n[2] = n[2] || n[0], n[3] = n[3] || n[1], n
      }, e.prototype._monitorIntersections = function () { this._monitoringIntersections || (this._monitoringIntersections = !0, this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (i(window, 'resize', this._checkForIntersections, !0), i(d, 'scroll', this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && 'MutationObserver' in window && (this._domObserver = new MutationObserver(this._checkForIntersections), this._domObserver.observe(d, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })))) }, e.prototype._unmonitorIntersections = function () { this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), this._monitoringInterval = null, r(window, 'resize', this._checkForIntersections, !0), r(d, 'scroll', this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), this._domObserver = null)) }, e.prototype._checkForIntersections = function () { const e = this._rootIsInDom(); const o = e ? this._getRootRect() : a(); this._observationTargets.forEach(function (i) { const r = i.element; const s = c(r); const a = this._rootContainsTarget(r); const u = i.entry; const l = e && a && this._computeTargetAndRootIntersection(r, o); const d = i.entry = new t({ time: n(), target: r, boundingClientRect: s, rootBounds: o, intersectionRect: l }); u ? e && a ? this._hasCrossedThreshold(u, d) && this._queuedEntries.push(d) : u && u.isIntersecting && this._queuedEntries.push(d) : this._queuedEntries.push(d) }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this) }, e.prototype._computeTargetAndRootIntersection = function (t, e) {
        if (window.getComputedStyle(t).display != 'none') {
          for (var n, o = c(t), i = l(t), r = !1; !r;) {
            let a = null; const u = i.nodeType == 1 ? window.getComputedStyle(i) : {}; if (u.display == 'none')
              return; if (i == this.root || i == d ? (r = !0, a = e) : i != d.body && i != d.documentElement && u.overflow != 'visible' && (a = c(i)), a && !(o = s(a, o)))
              break; i = l(i)
          } return o
        }
      }, e.prototype._getRootRect = function () {
        let t; if (this.root) {
          t = c(this.root)
        }
        else { const e = d.documentElement; const n = d.body; t = { top: 0, left: 0, right: e.clientWidth || n.clientWidth, width: e.clientWidth || n.clientWidth, bottom: e.clientHeight || n.clientHeight, height: e.clientHeight || n.clientHeight } } return this._expandRectByRootMargin(t)
      }, e.prototype._expandRectByRootMargin = function (t) { const e = this._rootMarginValues.map((e, n) => { return e.unit == 'px' ? e.value : e.value * (n % 2 ? t.width : t.height) / 100 }); const n = { top: t.top - e[0], right: t.right + e[1], bottom: t.bottom + e[2], left: t.left - e[3] }; return n.width = n.right - n.left, n.height = n.bottom - n.top, n }, e.prototype._hasCrossedThreshold = function (t, e) {
        const n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1; const o = e.isIntersecting ? e.intersectionRatio || 0 : -1; if (n !== o) {
          for (let i = 0; i < this.thresholds.length; i++) {
            const r = this.thresholds[i]; if (r == n || r == o || r < n != r < o)
              return !0
          }
        }
      }, e.prototype._rootIsInDom = function () { return !this.root || u(d, this.root) }, e.prototype._rootContainsTarget = function (t) { return u(this.root || d, t) }, e.prototype._registerInstance = function () { !f.includes(this) && f.push(this) }, e.prototype._unregisterInstance = function () { const t = f.indexOf(this); t != -1 && f.splice(t, 1) }, window.IntersectionObserver = e, window.IntersectionObserverEntry = t
    }
  }
}()), (function (t, e) { typeof exports == 'object' && typeof module != 'undefined' ? module.exports = e() : typeof define == 'function' && define.amd ? define(e) : (t = t || self).LazyLoad = e() }(this, () => {
  'use strict'; function t() { return (t = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const o in n)Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]) } return t }).apply(this, arguments) } const e = typeof window != 'undefined'; const n = e && !('onscroll' in window) || typeof navigator != 'undefined' && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent); const o = e && 'IntersectionObserver' in window; const i = e && 'classList' in document.createElement('p'); const r = e && window.devicePixelRatio > 1; const s = { elements_selector: '.lazy', container: n || e ? document : null, threshold: 300, thresholds: null, data_src: 'src', data_srcset: 'srcset', data_sizes: 'sizes', data_bg: 'bg', data_bg_hidpi: 'bg-hidpi', data_bg_multi: 'bg-multi', data_bg_multi_hidpi: 'bg-multi-hidpi', data_poster: 'poster', class_applied: 'applied', class_loading: 'loading', class_loaded: 'loaded', class_error: 'error', class_entered: 'entered', class_exited: 'exited', unobserve_completed: !0, unobserve_entered: !1, cancel_on_exit: !0, callback_enter: null, callback_exit: null, callback_applied: null, callback_loading: null, callback_loaded: null, callback_error: null, callback_finish: null, callback_cancel: null, use_native: !1 }; const c = function (e) { return t({}, s, e) }; const a = function (t, e) {
    let n; const o = 'LazyLoad::Initialized'; const i = new t(e); try { n = new CustomEvent(o, { detail: { instance: i } }) }
    catch (t) { (n = document.createEvent('CustomEvent')).initCustomEvent(o, !1, !1, { instance: i }) }window.dispatchEvent(n)
  }; const u = 'loading'; const l = 'loaded'; const d = 'applied'; const f = 'error'; const h = 'native'; const p = 'data-'; const g = 'll-status'; const _ = function (t, e) { return t.getAttribute(p + e) }; const m = function (t) { return _(t, g) }; const v = function (t, e) { return (function (t, e, n) { const o = 'data-ll-status'; n !== null ? t.setAttribute(o, n) : t.removeAttribute(o) }(t, 0, e)) }; const b = function (t) { return v(t, null) }; const y = function (t) { return m(t) === null }; const w = function (t) { return m(t) === h }; const E = [u, l, d, f]; const I = function (t, e, n, o) { t && (void 0 === o ? void 0 === n ? t(e) : t(e, n) : t(e, n, o)) }; const L = function (t, e) { i ? t.classList.add(e) : t.className += (t.className ? ' ' : '') + e }; const O = function (t, e) { i ? t.classList.remove(e) : t.className = t.className.replace(new RegExp(`(^|\\s+)${e}(\\s+|$)`), ' ').replace(/^\s+/, '').replace(/\s+$/, '') }; const R = function (t) { return t.llTempImage }; const T = function (t, e) { if (e) { const n = e._observer; n && n.unobserve(t) } }; const A = function (t, e) { t && (t.loadingCount += e) }; const k = function (t, e) { t && (t.toLoadCount = e) }; const M = function (t) { for (var e, n = [], o = 0; e = t.children[o]; o += 1)e.tagName === 'SOURCE' && n.push(e); return n }; const x = function (t, e, n) { n && t.setAttribute(e, n) }; const C = function (t, e) { t.removeAttribute(e) }; const S = function (t) { return !!t.llOriginalAttrs }; const q = function (t) { if (!S(t)) { const e = {}; e.src = t.getAttribute('src'), e.srcset = t.getAttribute('srcset'), e.sizes = t.getAttribute('sizes'), t.llOriginalAttrs = e } }; const N = function (t) { if (S(t)) { const e = t.llOriginalAttrs; x(t, 'src', e.src), x(t, 'srcset', e.srcset), x(t, 'sizes', e.sizes) } }; const z = function (t, e) { x(t, 'sizes', _(t, e.data_sizes)), x(t, 'srcset', _(t, e.data_srcset)), x(t, 'src', _(t, e.data_src)) }; const F = function (t) { C(t, 'src'), C(t, 'srcset'), C(t, 'sizes') }; const j = function (t, e) { const n = t.parentNode; n && n.tagName === 'PICTURE' && M(n).forEach(e) }; const V = { IMG(t, e) { j(t, (t) => { q(t), z(t, e) }), q(t), z(t, e) }, IFRAME(t, e) { x(t, 'src', _(t, e.data_src)) }, VIDEO(t, e) { !(function (t, n) { M(t).forEach((t) => { x(t, 'src', _(t, e.data_src)) }) }(t)), x(t, 'poster', _(t, e.data_poster)), x(t, 'src', _(t, e.data_src)), t.load() } }; const H = function (t, e) { const n = V[t.tagName]; n && n(t, e) }; const U = function (t, e, n) { A(n, 1), L(t, e.class_loading), v(t, u), I(e.callback_loading, t, n) }; const D = ['IMG', 'IFRAME', 'VIDEO']; const B = function (t, e) { !e || (function (t) { return t.loadingCount > 0 }(e)) || (function (t) { return t.toLoadCount > 0 }(e)) || I(t.callback_finish, e) }; const P = function (t, e, n) { t.addEventListener(e, n), t.llEvLisnrs[e] = n }; const G = function (t, e, n) { t.removeEventListener(e, n) }; const W = function (t) { return !!t.llEvLisnrs }; const $ = function (t) { if (W(t)) { const e = t.llEvLisnrs; for (const n in e) { const o = e[n]; G(t, n, o) } delete t.llEvLisnrs } }; const Y = function (t, e, n) { !(function (t) { delete t.llTempImage }(t)), A(n, -1), (function (t) { t && (t.toLoadCount -= 1) }(n)), O(t, e.class_loading), e.unobserve_completed && T(t, n) }; const J = function (t, e, n) { const o = R(t) || t; W(o) || (function (t, e, n) { W(t) || (t.llEvLisnrs = {}); const o = t.tagName === 'VIDEO' ? 'loadeddata' : 'load'; P(t, o, e), P(t, 'error', n) }(o, (i) => { !(function (t, e, n, o) { const i = w(e); Y(e, n, o), L(e, n.class_loaded), v(e, l), I(n.callback_loaded, e, o), i || B(n, o) }(0, t, e, n)), $(o) }, (i) => { !(function (t, e, n, o) { const i = w(e); Y(e, n, o), L(e, n.class_error), v(e, f), I(n.callback_error, e, o), i || B(n, o) }(0, t, e, n)), $(o) })) }; const K = function (t, e, n) { !(function (t) { t.llTempImage = document.createElement('IMG') }(t)), J(t, e, n), (function (t, e, n) { const o = _(t, e.data_bg); const i = _(t, e.data_bg_hidpi); const s = r && i ? i : o; s && (t.style.backgroundImage = 'url("'.concat(s, '")'), R(t).setAttribute('src', s), U(t, e, n)) }(t, e, n)), (function (t, e, n) { const o = _(t, e.data_bg_multi); const i = _(t, e.data_bg_multi_hidpi); const s = r && i ? i : o; s && (t.style.backgroundImage = s, (function (t, e, n) { L(t, e.class_applied), v(t, d), e.unobserve_completed && T(t, e), I(e.callback_applied, t, n) }(t, e, n))) }(t, e, n)) }; const Q = function (t, e, n) { !(function (t) { return D.includes(t.tagName) }(t)) ? K(t, e, n) : (function (t, e, n) { J(t, e, n), H(t, e), U(t, e, n) }(t, e, n)) }; const X = ['IMG', 'IFRAME']; const Z = function (t) { return t.use_native && 'loading' in HTMLImageElement.prototype }; const tt = function (t, e, n) { t.forEach((t) => { return (function (t) { return t.isIntersecting || t.intersectionRatio > 0 }(t)) ? (function (t, e, n, o) { v(t, 'entered'), L(t, n.class_entered), O(t, n.class_exited), (function (t, e, n) { e.unobserve_entered && T(t, n) }(t, n, o)), I(n.callback_enter, t, e, o), (function (t) { return E.includes(m(t)) }(t)) || Q(t, n, o) }(t.target, t, e, n)) : (function (t, e, n, o) { y(t) || (L(t, n.class_exited), (function (t, e, n, o) { n.cancel_on_exit && (function (t) { return m(t) === u }(t)) && t.tagName === 'IMG' && ($(t), (function (t) { j(t, (t) => { F(t) }), F(t) }(t)), (function (t) { j(t, (t) => { N(t) }), N(t) }(t)), O(t, n.class_loading), A(o, -1), b(t), I(n.callback_cancel, t, e, o)) }(t, e, n, o)), I(n.callback_exit, t, e, o)) }(t.target, t, e, n)) }) }; const et = function (t) { return Array.prototype.slice.call(t) }; const nt = function (t) { return t.container.querySelectorAll(t.elements_selector) }; const ot = function (t) { return (function (t) { return m(t) === f }(t)) }; const it = function (t, e) { return (function (t) { return et(t).filter(y) }(t || nt(e))) }; const rt = function (t, n) { const i = c(t); this._settings = i, this.loadingCount = 0, (function (t, e) { o && !Z(t) && (e._observer = new IntersectionObserver((n) => { tt(n, t, e) }, (function (t) { return { root: t.container === document ? null : t.container, rootMargin: t.thresholds || `${t.threshold}px` } }(t)))) }(i, this)), (function (t, n) { e && window.addEventListener('online', () => { !(function (t, e) { let n; (n = nt(t), et(n).filter(ot)).forEach((e) => { O(e, t.class_error), b(e) }), e.update() }(t, n)) }) }(i, this)), this.update(n) }; return rt.prototype = { update(t) { let e; let i; const r = this._settings; const s = it(t, r); k(this, s.length), !n && o ? Z(r) ? (function (t, e, n) { t.forEach((t) => { X.includes(t.tagName) && (t.setAttribute('loading', 'lazy'), (function (t, e, n) { J(t, e, n), H(t, e), v(t, h) }(t, e, n))) }), k(n, 0) }(s, r, this)) : (i = s, (function (t) { t.disconnect() }(e = this._observer)), (function (t, e) { e.forEach((e) => { t.observe(e) }) }(e, i))) : this.loadAll(s) }, destroy() { this._observer && this._observer.disconnect(), nt(this._settings).forEach((t) => { delete t.llOriginalAttrs }), delete this._observer, delete this._settings, delete this.loadingCount, delete this.toLoadCount }, loadAll(t) { const e = this; const n = this._settings; it(t, n).forEach((t) => { T(t, e), Q(t, n, e) }) } }, rt.load = function (t, e) { const n = c(e); Q(t, n) }, rt.resetStatus = function (t) { b(t) }, e && (function (t, e) {
    if (e) {
      if (e.length) {
        for (var n, o = 0; n = e[o]; o += 1)a(t, n)
      }
      else {
        a(t, e)
      }
    }
  }(rt, window.lazyLoadOptions)), rt
})), window.addEventListener('load', () => { const t = new SmoothScroll('a[href*="#"]', { speed: 1e3 }) })
